<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Ludo Telegram Mini App</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      text-align: center;
      background: #f0f0f0;
      margin: 0;
      padding: 10px;
      color: #333;
    }
    #game-container {
      max-width: 360px;
      margin: 0 auto;
    }
    canvas {
      border: 2px solid #333;
      background: #fff;
      width: 100%;
      max-width: 360px;
      height: 360px;
    }
    #info, #dice {
      font-size: 16px;
      margin: 8px 0;
      font-weight: bold;
    }
    button {
      padding: 8px 16px;
      margin: 4px;
      background: #0088cc;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
    }
    button:disabled {
      background: #ccc;
      cursor: not-allowed;
    }
    #move-buttons {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
    }
  </style>
</head>
<body>
  <div id="game-container">
    <h1 style="font-size: 20px; margin: 10px 0;">Ludo Mini App</h1>
    <div id="info">Initializing...</div>
    <div id="dice">Dice: -</div>
    <canvas id="board" width="360" height="360"></canvas>
    <button id="roll-btn" onclick="rollDice()">Roll Dice</button>
    <div id="move-buttons"></div>
  </div>

  <script src="https://telegram.org/js/telegram-web-app.js?57"></script>
  <script>
    // Telegram Web App initialization
    window.Telegram.WebApp.ready();
    const user = window.Telegram.WebApp.initDataUnsafe.user || { id: 'test' + Math.random(), username: 'TestUser' };
    document.getElementById('info').innerText = `Welcome, ${user.username}!`;

    // Game state
    const game = {
      players: [
        { id: user.id, color: 'red', pieces: [{ pos: -1 }, { pos: -1 }, { pos: -1 }, { pos: -1 }], start: 0, homePath: [52, 53, 54, 55, 56, 57], wins: 0 },
        { id: 'player2', color: 'blue', pieces: [{ pos: -1 }, { pos: -1 }, { pos: -1 }, { pos: -1 }], start: 13, homePath: [58, 59, 60, 61, 62, 63], wins: 0 },
        { id: 'player3', color: 'green', pieces: [{ pos: -1 }, { pos: -1 }, { pos: -1 }, { pos: -1 }], start: 26, homePath: [64, 65, 66, 67, 68, 69], wins: 0 },
        { id: 'player4', color: 'yellow', pieces: [{ pos: -1 }, { pos: -1 }, { pos: -1 }, { pos: -1 }], start: 39, homePath: [70, 71, 72, 73, 74, 75], wins: 0 }
      ],
      currentTurn: 0,
      dice: null,
      path: Array.from({ length: 52 }, (_, i) => i), // Shared outer path (0-51)
      winner: null
    };

    // Canvas setup
    const canvas = document.getElementById('board');
    const ctx = canvas.getContext('2d');
    const size = 360 / 15; // 15x15 grid

    // Draw Ludo board
    function drawBoard() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      // Outer path (simplified as a square)
      const pathCoords = [
        ...Array.from({ length: 13 }, (_, i) => ({ x: i + 1, y: 1 })), // Top
        ...Array.from({ length: 13 }, (_, i) => ({ x: 14, y: i + 1 })), // Right
        ...Array.from({ length: 13 }, (_, i) => ({ x: 14 - i, y: 14 })), // Bottom
        ...Array.from({ length: 13 }, (_, i) => ({ x: 1, y: 14 - i })) // Left
      ];
      pathCoords.forEach(({ x, y }, i) => {
        ctx.strokeStyle = '#333';
        ctx.strokeRect(x * size, y * size, size, size);
        if ([0, 13, 26, 39].includes(i)) ctx.fillStyle = game.players.find(p => p.start === i).color;
        else ctx.fillStyle = '#fff';
        ctx.fillRect(x * size + 1, y * size + 1, size - 2, size - 2);
      });
      // Home paths
      game.players.forEach(p => {
        p.homePath.forEach((_, i) => {
          const x = 7 + (p.color === 'red' ? i + 1 : p.color === 'blue' ? -i - 1 : 0);
          const y = 7 + (p.color === 'green' ? i + 1 : p.color === 'yellow' ? -i - 1 : 0);
          ctx.fillStyle = p.color;
          ctx.fillRect(x * size, y * size, size, size);
        });
      });
      // Center (winning square)
      ctx.fillStyle = '#ccc';
      ctx.fillRect(7 * size, 7 * size, size, size);
      // Home triangles (simplified)
      game.players.forEach(p => {
        const home = p.color === 'red' ? { x: 2, y: 2 } : p.color === 'blue' ? { x: 12, y: 2 } :
                     p.color === 'green' ? { x: 12, y: 12 } : { x: 2, y: 12 };
        ctx.fillStyle = p.color;
        ctx.fillRect(home.x * size, home.y * size, size * 2, size * 2);
      });
      // Draw pieces
      game.players.forEach(p => {
        p.pieces.forEach((piece, i) => {
          if (piece.pos >= 0) {
            let x, y;
            if (piece.pos < 52) {
              x = pathCoords[piece.pos].x * size + size / 2;
              y = pathCoords[piece.pos].y * size + size / 2;
            } else {
              const hpIndex = p.homePath.indexOf(piece.pos);
              x = (7 + (p.color === 'red' ? hpIndex + 1 : p.color === 'blue' ? -hpIndex - 1 : 0)) * size + size / 2;
              y = (7 + (p.color === 'green' ? hpIndex + 1 : p.color === 'yellow' ? -hpIndex - 1 : 0)) * size + size / 2;
            }
            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.arc(x, y, size / 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = 'white';
            ctx.font = '10px Arial';
            ctx.fillText(i + 1, x - 5, y + 3);
          } else {
            const home = p.color === 'red' ? { x: 2.5, y: 2.5 } : p.color === 'blue' ? { x: 12.5, y: 2.5 } :
                         p.color === 'green' ? { x: 12.5, y: 12.5 } : { x: 2.5, y: 12.5 };
            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.arc(home.x * size, home.y * size, size / 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = 'white';
            ctx.font = '10px Arial';
            ctx.fillText(i + 1, home.x * size - 5, home.y * size + 3);
          }
        });
      });
    }

    // Update info
    function updateInfo() {
      const player = game.players[game.currentTurn];
      document.getElementById('info').innerText = game.winner ? `${game.winner.color} wins!` :
        `Turn: ${player.color} | ${player.id === user.id ? user.username : player.id}`;
      document.getElementById('dice').innerText = `Dice: ${game.dice || '-'}`;
      document.getElementById('roll-btn').disabled = player.id !== user.id || game.dice || game.winner;
      renderMoveButtons();
      drawBoard();
    }

    // Render move buttons
    function renderMoveButtons() {
      const buttonsDiv = document.getElementById('move-buttons');
      buttonsDiv.innerHTML = '';
      if (game.dice && game.players[game.currentTurn].id === user.id && !game.winner) {
        game.players[game.currentTurn].pieces.forEach((piece, i) => {
          if (piece.pos >= 0 || game.dice === 6) {
            const button = document.createElement('button');
            button.innerText = `Move Piece ${i + 1}`;
            button.onclick = () => movePiece(i);
            buttonsDiv.appendChild(button);
          }
        });
      }
    }

    // Roll dice
    function rollDice() {
      if (game.players[game.currentTurn].id === user.id && !game.dice && !game.winner) {
        game.dice = Math.floor(Math.random() * 6) + 1;
        updateInfo();
        if (game.dice !== 6 && !game.players[game.currentTurn].pieces.some(p => p.pos >= 0)) {
          game.dice = null;
          game.currentTurn = (game.currentTurn + 1) % game.players.length;
          setTimeout(playAITurn, 500);
        }
      }
    }

    // Move piece
    function movePiece(pieceIndex) {
      if (game.players[game.currentTurn].id === user.id && game.dice && !game.winner) {
        const player = game.players[game.currentTurn];
        const piece = player.pieces[pieceIndex];
        let newPos = piece.pos;
        if (piece.pos === -1 && game.dice === 6) {
          newPos = player.start;
        } else if (piece.pos >= 0) {
          const pathIndex = piece.pos < 52 ? piece.pos - player.start : 52;
          const steps = piece.pos < 52 ? game.dice : game.dice - (52 - (piece.pos - player.start));
          newPos = piece.pos < 52 ? (piece.pos + game.dice) % 52 : player.homePath[steps - 1] || piece.pos;
        } else {
          return;
        }
        // Capture
        if (newPos < 52) {
          game.players.forEach((opponent, i) => {
            if (i !== game.currentTurn) {
              opponent.pieces.forEach(p => {
                if (p.pos === newPos) p.pos = -1;
              });
            }
          });
        }
        piece.pos = newPos;
        // Check win
        if (player.pieces.every(p => p.pos === player.homePath[5])) {
          game.winner = player;
        }
        // Extra turn for 6
        if (game.dice === 6 && !game.winner) {
          game.dice = null;
          updateInfo();
        } else {
          game.dice = null;
          game.currentTurn = (game.currentTurn + 1) % game.players.length;
          updateInfo();
          setTimeout(playAITurn, 500);
        }
      }
    }

    // AI for other players
    function playAITurn() {
      if (game.players[game.currentTurn].id !== user.id && !game.winner) {
        game.dice = Math.floor(Math.random() * 6) + 1;
        updateInfo();
        const player = game.players[game.currentTurn];
        const movable = player.pieces.map((p, i) => ({ pos: p.pos, index: i }))
          .filter(p => p.pos >= 0 || game.dice === 6);
        if (movable.length > 0) {
          const piece = movable[Math.floor(Math.random() * movable.length)];
          setTimeout(() => {
            let newPos = piece.pos;
            if (piece.pos === -1 && game.dice === 6) {
              newPos = player.start;
            } else if (piece.pos >= 0) {
              const pathIndex = piece.pos < 52 ? piece.pos - player.start : 52;
              newPos = piece.pos < 52 ? (piece.pos + game.dice) % 52 : player.homePath[game.dice - 1] || piece.pos;
            }
            if (newPos < 52) {
              game.players.forEach((opponent, i) => {
                if (i !== game.currentTurn) {
                  opponent.pieces.forEach(p => {
                    if (p.pos === newPos) p.pos = -1;
                  });
                }
              });
            }
            player.pieces[piece.index].pos = newPos;
            if (player.pieces.every(p => p.pos === player.homePath[5])) {
              game.winner = player;
            }
            if (game.dice === 6 && !game.winner) {
              game.dice = null;
              updateInfo();
              setTimeout(playAITurn, 500);
            } else {
              game.dice = null;
              game.currentTurn = (game.currentTurn + 1) % game.players.length;
              updateInfo();
            }
          }, 500);
        } else {
          game.dice = null;
          game.currentTurn = (game.currentTurn + 1) % game.players.length;
          updateInfo();
        }
      }
    }

    // Initialize
    drawBoard();
    updateInfo();
  </script>
</body>
</html>
